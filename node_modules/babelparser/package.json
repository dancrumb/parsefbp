{
  "name": "babelparser",
  "version": "0.1.0",
  "description": "General Babel Parser functions for scanners  ",
  "main": "script/babelparser.js",
  "directories": {
    "doc": "docs"
  },
  "scripts": {
    "test": "node ././parsefbp/script/test.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/jpaulm/babelparser.git"
  },
  "keywords": [
    "parser",
    "babel",
    "syntax"
  ],
  "author": {
    "name": "J. Paul Morrison",
    "email": "paul.morrison@rogers.com",
    "url": "http://jpaulmorrison.com/"
  },
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/jpaulm/babelparser/issues"
  },
  "homepage": "https://github.com/jpaulm/babelparser",
  "readme": "# The BabelParser\r\n\r\nThe BabelParser is a low-level parsing concept that supports its own graphical notation. It was invented in the UK many \r\nyears ago, and I have since ported it to just about every environment I've ever worked in.\r\n\r\nIt uses an input stream, and an output stream, each of which has its own pointer. As each character in the input is \r\nscanned off and recognized successfully, it is optionally copied to the output stream, and the input pointer (also optionally, \r\nalthough usually) steps to point at the next character in the input stream.\r\n\r\nThe most common operation is a \"character comparator\", although there are also \"class comparators\" (letters and/or numbers), \r\nand the \"universal comparator\", which is always true. The default action is to copy a recognized character to the output, but \r\nthis can be overridden by \"I-modification\" (the input pointer is not stepped) or \"O-modification\" (where copying does not \r\ntake place) or both. If both, O-modification is tested for before I-modification.\r\n\r\nIn Babel diagrams, a comparator is represented by a circle or a square, and a true result by a line exiting to the right, and \r\na false result by a line exiting downwards (in this case no pointers move, and no copying takes place). The universal comparator \r\nunmodified is also called \"copy\", while with O-modification, it is called \"skip\".\r\n\r\nSuppose I want to test for A, B or C, followed by 0 or more blanks (which won't be copied to the output stream), this can be \r\nrepresented as follows (I'll have to use squares for everything, and 'b' for blank):\r\n\r\n```\r\n            \r\n                         *--------------*\r\n                         |              | \r\n        *-----*          V   *-----*    |\r\n  ----->|  A  |-----*------->|  b  |----*\r\n        *-----*     |        *-----*\r\n           |        |           |  O-mod\r\n        *-----*     |           |            \r\n        |  B  |-----*           *----------->  we have found the first non-blank\r\n        *-----*     |\r\n           |        |\r\n        *-----*     |\r\n        |  C  |-----*\r\n        *-----*\r\n           |\r\n           \r\n```           \r\n\r\nOn completion of this scan, the output stream will contain A, B or C, and the output pointer will be positioned after \r\nthis letter.  Any consecutive blanks will be skipped, up to the first non-blank.\r\n\r\nIf none of A, B, or C was found at the position marked by the I-pointer, the logic will proceed to the code \"below\" the \r\ntest for 'C'.\r\n\r\nOne more example: we want to test if the current character is a '<', and, if it is, copy all the following characters to \r\nthe output stream, up to but not including the following '>'. I will use 'U' for the universal comparator.     \r\n\r\n```\r\n                         \r\n        *-----*                   *-----*      \r\n  ----->|  <  |-----------*------>|  >  |------ we have found the '>' and are \r\n        *-----*           |       *-----*               positioned just beyond it,\r\n           |  O-mod       |          |  O-mod           and the intervening characters\r\n           |              |          |                  are in the output stream\r\n        not a '<'         |       *-----*\r\n                          |       |  U  |-----*  (remember the universal comparator\r\n                          |       *-----*     |       is always true - so without \r\n                          |                   |       O-mod, it is a 'copy') \r\n                          *-------------------*\r\n\r\n```\r\n",
  "readmeFilename": "README.md",
  "_id": "babelparser@0.1.0",
  "dist": {
    "shasum": "a552e9598078a87d3ca7ba82ab1bab1bcf9927a4"
  },
  "_resolved": "git://github.com/jpaulm/babelparser#bf1991bbfb1f22f63fd502116609ea37cfddb157",
  "_from": "git://github.com/jpaulm/babelparser",
  "_fromGithub": true
}
